;; ruby and friends
(autoload 'ruby-mode "ruby-mode"
  "Mode for editing ruby source files" t)
(autoload 'run-ruby "inf-ruby"
  "Run an inferior Ruby process" t)
(autoload 'inf-ruby-keys "inf-ruby"
  "Set local key defs for inf-ruby in ruby-mode")
(autoload 'rdebug "rdebug" t
  "Run rdebug on program FILE in buffer *gud-FILE*.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.")

(defun ruby-eval-buffer ()
  (interactive)
  "Evaluate the buffer with ruby."
  (shell-command-on-region (point-min) (point-max) "ruby"))

(require 'ruby-electric)
(add-hook 'ruby-mode-hook
          '(lambda ()
             (inf-ruby-keys)
             (define-key ruby-mode-map "\C-c\C-a" 'ruby-eval-buffer)
             ;; (pabbrev-mode t) doh
             (ruby-electric-mode t))
             (if (eq emacs-major-version 22)
                 (progn
                   (make-local-variable 'write-contents-functions)
                   (add-hook 'write-contents-functions '(lambda ()
                                                          (untabify-buffer)
                                                          (delete-trailing-whitespace))))
               (make-local-variable 'write-contents-hooks)
               (add-hook'write-contents-hooks 'untabify-buffer)))

(add-hook 'ruby-inferior-mode-hook
          '(lambda ()
             (ruby-electric-mode t)))

(setq ri-ruby-script (concat emacs-root "/modes/ri-emacs.rb"))
(autoload 'ri "ri-ruby" "Ruby api reference" t)

;; (smart-snippet-with-abbrev-table 'ruby-mode-abbrev-table
;;   ('if' 'if $${condition} $.' '(not in-comment?))
;;   ('if' 'if $${condition}\n$>$.\nend$>\n' 'bol?))

;; ruby-specific pickens from rails-snippets.el
(snippet-with-abbrev-table 'ruby-mode-abbrev-table
       ("while" . "while $${condition}\n$>$.\nend$>")
       ("when" . "when $${condition}\n$>$.")
       ("w" . "attr_writer :$${attr_names}")
       ("upt" . "upto($${0}) { |$${n}|$. }")
       ("until" . "until $${condition}\n$>$.\nend$>")
       ("tim" . "times { |$${n}|$. }")
       ("ste" . "step($${2}) { |$${n}|$. }")
       ("for" . "for $${element} in $${collection}\n$>$${element}.$.\nend$>")
       ("dow" . "downto($${0}) { |$${n}|$. }")
;;        ("ha" . "{ $>:$. }")
;;        (":" . ":$${key} => '$${value}'" ":key => 'value'")
;;        ("yl" . "File.open($${yaml}) { |$${file}| YAML.load($${file}) }")
;;        ("yd" . "File.open($${yaml}, \"w\") { |$${file}| YAML.dump($${obj}, $${file}) }")
;;        ("y" . " :yields: $${arguments}")
       ("sub" . "sub(/$${pattern}/) { |$${match}|$. }")
       ("sub!" . "sub!(/$${pattern}/) { |$${match}|$. }")
       ("sca" . "scan(/$${pattern}/) { |$${match}| $. }")
       ("rb" . "#!/usr/bin/env ruby -w\n\n")
       ("r" . "attr_reader :$${attr_names}")
;;        ;; ("pn" . "PStore.new($${file_name}")
;;        ("patfh" . "File.join(File.dirname(__FILE__), *%w[$${here}]")
       ("ope" . "open($${pipe}) { |$${io}| $. }")
;;        ("ml" . "File.open($${dump}) { |$${file}| Marshal.load($${file}) }")
       ("min" . "min { |a, b| $. }")
       ("max" . "max { |a, b| $. }")
;;        ("md" . "File.open($${dump}, \"w\") { |$${file}| Marshal.dump($${obj}, $${file}) }")
;;        ("lam" . "lambda { |$${args}|$. }")
       ("proc" . "Proc.new { |$${args}| $. }")
       ("gsu" . "gsub(/$${pattern}/) { |$${match}|$. }")
       ("gsu!" . "gsub!(/$${pattern}/) { |$${match}|$. }")
       ("gre" . "grep($${pattern}) { |$${match}| $. }")
       ("fl" . "flunk('$${message}'")
       ("file" . "File.foreach($${file}) { |$${line}| $. }")
       ("dir" . "Dir.glob($${glob}) { |$${file}| $. }")
;;        ("b" . "=begin rdoc\n$>$.\n=end")
       ("begin" . "begin\n$>$${paste}\nrescue $${Exception} => $${e}\n$>$.\nend$>\n")
;;        ;; ("bm" . "TESTS = $${10_000}\nBenchmark.bmbm($${10}) do |results|\n  $.\nend$>")
;;        ("am" . "alias_method :$${new_name}, :$${old_name}")
;;        ("amc" . "alias_method_chain :$${first_method}, :$${second_method}") ; general
;;        ("ts" . "require \"test/unit\"\n\nrequire \"tc_$${test_case_file}\"\nrequire \"tc_$${test_case_file}\"\n" "require \"tc_...\")...")
;;        ("tc" . "require \"test/unit\"\n\nrequire \"$${library_file_name}\"\n\nclass Test$${amp} < Test::Unit::TestCase\n$>def test_$${case_name}\n$>$>$.\nend$>\nend$>")
       ("sin" . "class << self; self end")
       ("rw" . "attr_accessor :$${attr_names}")
       ("req" . "require \"$.\"")
;;        ("modf" . "module $${ModuleName}\n$>module ClassMethods\n$>$>$.\nend$>\n$>\n$>extend ClassMethods\n$>\n$>def self.included(receiver)\n$>$>receiver.extend(ClassMethods)\nend$>\n$>\n$>\nend$>")
;;        ("mods" . "module $${ModuleName}\n$>$.\nend$>")
;;        ("modu" . "module $${ModuleName}\n$>module_function\n$>\n$>$.\nend$>")
;;        ("mm" . "def method_missing(meth, *args, &block)\n$>$.\nend$>")
       ("hash" . "Hash.new { |$${hash}, $${key}| $${hash}[$${key}] = $. }")
;;        ("forw" . "extend Forwardable")
       ("enum" . "include Enumerable\n\ndef each(&block)\n$>$.\nend$>")
       ("elsif" . "elsif $${condition}\n$>$.")
       ("doo" . "do |$${object}|\n$>$.\nend$>")
       ("do" . "do\n$>$.\nend$>")
;;        ("defd" . "def_delegator :$${del_obj}, :$${del_meth}, :$${new_name}")
;;        ("defds" . "def_delegators :$${del_obj}, :$${del_methods}")
       ("defs" . "def self.$${class_method_name}\n$>$.\nend$>")
       ("deft" . "def test_$${case_name}\n$>$.\nend$>")
;;        ("dee" . "Marshal.load(Marshal.dump($${obj_to_copy})")
;;        ("comp" . "include Comparable\n\ndef <=>(other)\n$>$.\nend$>")
       ("cladl" . "class $${ClassName} < DelegateClass($${ParentClass})\n$>def initialize$${1}\n$>$>super($${del_obj})\n$>$>\n$>$>$.\nend$>\n$>\n$>\nend$>")
       ("clapr" . "class $${ClassName} < $${ParentClass}\n$>def initialize$${1}\n$>$>$.\nend$>\n$>\n$>\nend$>")
       ("clast" . "class $${ClassName} < Struct.new(:$${attr_names})\n$>def initialize(*args)\n$>$>super\n$>$>\n$>$>$.\nend$>\n$>\n$>\nend$>")
       ("class" . "class $${ClassName}\n$>$.\nend$>")
       ("classi" . "class $${ClassName}\n$>def initialize$${1}\n$>$>$.\nend$>\n$>\n$>\nend$>")
       ("clasf" . "class << $${self}\n$>$.\nend$>") ; definitions
       ("zip" . "zip($${enums}) { |$${row}| $. }")
       ("sorb" . "sort_by { |$${e}| $. }")
       ("sor" . "sort { |a, b| $. }")
       ("select" . "select { |$${element}| $${element}.$${2} }$.")
       ("sel" . "select { |$${e}| $. }")
       ("reve" . "reverse_each { |$${e}| $. }")
       ("reject" . "reject { |$${element}| $${element}.$. }")
       ("rej" . "reject { |$${e}| $. }")
       ("ran" . "sort_by { rand }")
       ("mapwi" . "enum_with_index.map { |$${e}, $${i}| $. }")
       ("map" . "map { |$${e}| $. }")
       ("inject" . "inject($${object}) { |$${injection}, $${element}| $${4} }$.")
       ("inj" . "inject($${init}) { |$${mem}, $${var}| $. }")
       ("flao" . "inject(Array.new) { |$${arr}, $${a}| $${arr}.push(*$${a}) }")
       ("fina" . "find_all { |$${e}| $. }")
       ("fin" . "find { |$${e}| $. }")
       ("fil" . "fill($${range}) { |$${i}|$. }")
       ("fet" . "fetch($${name}) { |$${key}|$. }")
       ("eawi" . "each_with_index { |$${e}, $${i}| $. }")
       ("eai" . "each_index { |$${i}| $. }")
       ("eak" . "each_key { |$${key}| $. }")
       ("eal" . "each_line$${1} { |$${line}| $. }")
       ("eap" . "each_pair { |$${name}, $${val}| $. }")
       ("eas" . "each_slice($${2}) { |$${group}| $. }")
       ("eav" . "each_value { |$${val}| $. }")
       ("each" . "each { |$${element}| $${element}.$. }")
       ("eac" . "each_cons($${2}) { |$${group}| $. }")
       ("eab" . "each_byte { |$${byte}| $. }")
       ("ea" . "each { |$${e}| $. }")
       ("det" . "detect { |$${e}| $. }")
       ("deli" . "delete_if { |$${e}| $. }")
       ("collect" . "collect { |$${element}| $${element}.$. }")
       ("col" . "collect { |$${e}| $. }")
       ("cl" . "classify { |$${e}| $. }")
       ("array" . "Array.new($${10}) { |$${i}|$. }")
       ("any" . "any? { |$${e}| $. }")
       ("all" . "all? { |$${e}| $. }")) ; collections