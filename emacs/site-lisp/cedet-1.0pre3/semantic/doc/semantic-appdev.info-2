This is semantic-appdev.info, produced by makeinfo version 4.3 from
app-dev-guide.texi.

This manual documents Application Development with Semantic.

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Eric M. Ludlam
Copyright (C) 2001, 2002, 2003, 2004 David Ponce Copyright (C) 2002,
2003 Richard Y. Kim

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with the Invariant Sections being list their titles,
     with the Front-Cover Texts being list, and with the Back-Cover
     Texts being list.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Semantic Application Writer's guide: (semantic-appdev).
END-INFO-DIR-ENTRY

   This file documents Application Development with Semantic.
_Infrastructure for parser based text analysis in Emacs_

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam,
David Ponce, and Richard Y. Kim


File: semantic-appdev.info,  Node: Tag Secondary Overlays,  Next: Tag Folding,  Prev: Tag Visible Properties,  Up: Tag Decoration

Secondary Overlays
==================

Each tag which is being visited in a buffer has one overlay.  This
overlay is used to track where the tag is while a user is editing, and
can also be used for fast tag identification, and some simple
decoration techniques.

A secondary overlay associates a new overlay object with a tag which
does not cover the entire body of a tag.  You can then put visible
features on that overlay to decorate portions of a tag.  This is how
tag boundaries are drawn.

Creation and Deletion
---------------------

 - Function: semantic-tag-create-secondary-overlay tag &optional
          link-hook
     Create a secondary overlay for TAG.  Returns an overlay.  The
     overlay is also saved in TAG.  LINK-HOOK is a function called
     whenever TAG is to be linked into a buffer.  It should take TAG
     and OVERLAY as arguments.  The LINK-HOOK should be used to
     position and set properties on the generated secondary overlay.

 - Function: semantic-tag-delete-secondary-overlay tag
          overlay-or-property
     Delete from TAG the secondary overlay OVERLAY-OR-PROPERTY.  If
     OVERLAY-OR-PROPERTY is an overlay, delete that overlay.  If
     OVERLAY-OR-PROPERTY is a symbol, find the overlay with that
     property.

Queries
-------

 - Function: semantic-tag-get-secondary-overlay tag property
     Return secondary overlays from TAG with PROPERTY.  PROPERTY is a
     symbol and all overlays with that symbol are returned..

 - Function: semantic-tag-secondary-overlays tag
     Return a list of secondary overlays active on TAG.

Linking and Unlinking
---------------------

When a tag's file is put in a buffer, that tag is "linked" into the
buffer.  When the buffer is deleted, the tag is "unlinked".  This
process adds and removes the default overlay on the tag.  Secondary
overlays use `semantic-tag-add-hook' and `semantic-tag-remove-hook' too
apply link and unlink hooks.

This allows the secondary overlays to be automatically removed or added
by the seconary overlay system whenever a tag's file goes in or out of
a buffer.


File: semantic-appdev.info,  Node: Tag Folding,  Prev: Tag Secondary Overlays,  Up: Tag Decoration

Folding
=======

Using secondary overlays, a set of tag folding routines are made
available.  These routines are similar to the tag visible properties.

 - Function: semantic-set-tag-folded tag &optional folded
     Fold TAG, such that only the first line of text is shown.
     Optional argument FOLDED should be non-`nil' to fold the tag.
     `nil' implies the tag should be fully shown.

 - Function: semantic-tag-folded-p tag
     Non-`nil' if TAG is currently folded.


File: semantic-appdev.info,  Node: Tag Sorting,  Next: Tag Completion,  Prev: Tag Decoration,  Up: Top

Tag Sorting
***********

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the tag
list for you.

 - Function: semantic-unique-tag-table tags
     Scan a list of TAGS, removing duplicates.  This must first sort
     the tags by position ascending.  TAGS are removed only if they are
     equivalent, as can happen when multiple tag sources are scanned.

 - Function: semantic-unique-tag-table-by-name tags
     Scan a list of TAGS, removing duplicate names.  This must first
     sort the tags by name alphabetically ascending.

 - Function: semantic-bucketize tags &optional parent filter
     Sort TAGS into a group of buckets based on tag class.  Unknown
     classes are placed in a Misc bucket.  Type bucket names are
     defined by either `semantic-symbol->name-assoc-list'.  If PARENT
     is specified, then TAGS belong to this PARENT in some way.  This
     will use `semantic-symbol->name-assoc-list-for-type-parts' to
     generate bucket names.  Optional argument FILTER is a filter
     function to be applied to each bucket.  The filter function will
     take one argument, which is a list of tags, and may re-organize
     the list with side-effects.

 - Variable: semantic-bucketize-tag-class
     Function used to get a symbol describing the class of a token.
     This function must take one argument of a semantic token.  It
     should return a symbol found in `semantic-symbol->name-assoc-list'
     which "semantic-bucketize" uses to bin up tokens.  To create new
     bins for an application augment
     `semantic-symbol->name-assoc-list', and
     `semantic-symbol->name-assoc-list-for-type-parts' in addition to
     setting this variable (locally in your function).

 - Function: semantic-adopt-external-members tags
     Rebuild TAGS so that externally defined members are regrouped.
     Some languages such as C++ and CLOS permit the declaration of
     member functions outside the definition of the class.  It is
     easier to study the structure of a program when such methods are
     grouped together more logically.

     This function uses "semantic-nonterminal-external-member-p" to
     determine when a potential child is an externally defined member.

     Note: Applications which use this function must account for tag
     types which do not have a position, but have children which *do*
     have positions.

     Applications should use `semantic-mark-external-member-function'
     to modify all tags which are found as externally defined to some
     type.  For example, changing the tag type for generating extra
     buckets with the bucket function.

 - Variable: semantic-orphaned-member-metaparent-type
     In "semantic-adopt-external-members", the type of `'type' for
     metaparents.  A metaparent is a made-up type semantic tag used to
     hold the child list of orphaned members of a named type.

 - Variable: semantic-mark-external-member-function
     Function called when an externally defined orphan is found.  Be
     default, the tag is always marked with the `adopted' property.
     This function should be locally bound by a program that needs to
     add additional behaviors into the tag list.  This function is
     called with one argument which is a shallow copy of the tag to be
     modified.  This function should return the tag (or a copy of it)
     which is then integrated into the revised tag list.


File: semantic-appdev.info,  Node: Tag Completion,  Next: Override Methods,  Prev: Tag Sorting,  Up: Top

Tag Completion
**************

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time, the
semantics can be quite complex.  If two tags have the same name, which
do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the "interactive" command like this:

     (defun my-function (tag)
        "Do something to TAG."
        (interactive (list (my-completion-function "Tag: ")))
        ...)

* Menu:

* Tag Completion Convenience Functions::  Provided functions
* Custom Tag Completion Functions::  Build your own completion function
* Old Tag Completion::          Completion functions from older releases


File: semantic-appdev.info,  Node: Tag Completion Convenience Functions,  Next: Custom Tag Completion Functions,  Up: Tag Completion

Tag Completion Convenience Functions
====================================

There are some pre written completion functions that can be used in your
programs.

 - Function: semantic-complete-read-tag-buffer-deep prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current buffer.  Available tags are
     from the current buffer, at any level.  Completion options are
     presented in a traditional way, with highlighting to resolve
     same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to story
     the history in.


File: semantic-appdev.info,  Node: Custom Tag Completion Functions,  Next: Old Tag Completion,  Prev: Tag Completion Convenience Functions,  Up: Tag Completion

Custom Tag Completion Functions
===============================

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

Tag Collection
     Something that selects tags, and provides some list of tags
     available, such as all functions, or all classes named "bob".

Typing and selecting
     The prompt where you can type in the name of a tag.

Displaying possible completion values
     A mechanism for displaying completion lists.

There is one typing and selecting routine that can be used to create
your custom completion prompt.

 - Function: semantic-complete-read-tag-engine collector displayor
          prompt default-tag initial-input history
     Read a semantic tag, and return a tag for the selection.  Argument
     COLLECTOR is a function which can be used to to return a list of
     possible hits.  See `semantic-completion-collector-engine' for
     details on COLLECTOR.  Argumeng DISPLAYOR is a function used to
     display a list of possible completions for a given prefix.
     See`semantic-completion-display-engine' for details on DISPLAYOR.
     PROMPT is a string to prompt with.  DEFAULT-TAG is a semantic tag
     or string to use as the default value.  If INITIAL-INPUT is
     non-`nil', insert it in the minibuffer initially.  HISTORY is a
     symbol representing a variable to story the history in.

As you can see, this takes one "collector", and one "displayor".  These
are objects created for this prompt at runtime.  The completion engine
then uses to perform their tasks.

For example:

     (defun semantic-complete-read-tag-buffer-deep (prompt &optional
     						      default-tag initial-input history)
       "Ask for a tag by name from the current buffer.
     PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default value.
     If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
     HISTORY is a symbol representing a variable to story the history in."
       (semantic-complete-read-tag-engine
        (semantic-collector-buffer-deep prompt :buffer (current-buffer))
        (semantic-displayor-traditional-with-focus-highlight "simple")
        ;;(semantic-displayor-tooltip "simple")
        prompt
        default-tag
        initial-input
        history)
       )

* Menu:

* Tag Collectors::
* Tag Displayors::


File: semantic-appdev.info,  Node: Tag Collectors,  Next: Tag Displayors,  Up: Custom Tag Completion Functions

Tag Collectors
--------------

A tag collector is an object that inherits from
"semantic-collector-abstract".  A new collector is needed for each
specialized type of prompt that draws from a different selection of
tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

All collectors inherit from:

 - Type: semantic-collector-abstract
     Root class for completion engines.

Available instantiable classes are:

 - Type: semantic-collector-buffer-deep
     Completion engine for tags in the current buffer.  Provides deep
     searches through types.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Tag Displayors,  Prev: Tag Collectors,  Up: Custom Tag Completion Functions

Tag Displayors
--------------

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to focus one one particular tag
of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

 - Type: semantic-displayor-abstract
     Manages the display of some number of tags.

Distinct implementations of displayors include:

 - Type: semantic-displayor-traditional
     Traditional display mechanism for a list of possible completions.

 - Type: semantic-displayor-traditional-with-focus-highlight
     A traditional displayor which can focus on a tag by showing it.

 - Type: semantic-displayor-tooltip
     Display mechanism using tooltip for a list of possible completions.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Old Tag Completion,  Prev: Custom Tag Completion Functions,  Up: Tag Completion

Older Tag Completion functions
==============================

These are older completion functions.  They may still be useful.

 - Function: semantic-read-symbol prompt &optional default stream filter
     Read a symbol name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.  FILTER is provides a
     filter on the types of things to complete.  FILTER must be a
     function to call on each element.  (See !!!

 - Function: semantic-read-variable prompt &optional default stream
     Read a variable name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 - Function: semantic-read-function prompt &optional default stream
     Read a function name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 - Function: semantic-read-type prompt &optional default stream
     Read a type name from the user for the current buffer.  PROMPT is
     the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.


File: semantic-appdev.info,  Node: Override Methods,  Next: Parser Features,  Prev: Tag Completion,  Up: Top

Override Methods
****************

These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

If you plan to use one of these functions from a buffer that is not of
the same major-mode as the original tag, you can use this form to make
sure th correct action takes place:

 - Function: semantic-with-mode-bindings mode &rest body
     Evaluate BODY with the local bindings of MODE.  The current mode
     bindings are saved, BODY is evaluated, and the saved bindings are
     restored, even in case of an abnormal exit.  Value is what BODY
     returns.

For more on override methods, *note (lang-support-guide)Semantic
Overload Mechanism::.

* Menu:

* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Making New Methods::          How to add your own methods for a tool


File: semantic-appdev.info,  Node: Format Tag,  Next: Tag Members,  Up: Override Methods

Format Tag
==========

Any given tag consists of Meta information which is best viewed in some
textual form.  This could be as simple as the tag's name, or as a
prototype to be added to header file in C.  Not only are there several
default converters from a Tag into text, but there is also some
convenient variables that can be used with them.  Use these variables
to allow options on output forms when displaying tags in your programs.

 - Variable: semantic-format-tag-functions
     List of functions which convert a tag to text.  Each function must
     take the parameters TAG &optional PARENT COLOR.  TAG is the tag to
     convert.  PARENT is a parent tag or name which refers to the
     structure or class which contains TAG.  PARENT is NOT a class
     which a TAG would claim as a parent.  COLOR indicates that the
     generated text should be colored using `font-lock'.

 - Variable: semantic-format-tag-custom-list
     A List used by customizeable variables to choose a tag to text
     function.  Use this variable in the `:type' field of a
     customizable variable.

Every tag to text conversion function must take the same parameters,
which are TAG, the tag to be converted, PARENT, the containing parent
(like a structure which contains a variable), and COLOR, which is a
flag specifying that color should be applied to the returned string.

When creating, or using these strings, particularly with color, use
"concat" to build up larger strings instead of "format".  This will
preserve text properties.

 - Function: semantic-format-tag-name tag &optional parent color
     Return the name string describing TAG.  The name is the shortest
     possible representation.  Optional argument PARENT is the parent
     type if TAG is a detail.  Optional argument COLOR means highlight
     the prototype with font-lock colors.

 - Function: semantic-format-tag-abbreviate tag &optional parent color
     Return an abbreviated string describing TAG.  The abbreviation is
     to be short, with possible symbols indicating the type of tag, or
     other information.  Optional argument PARENT is the parent type if
     TAG is a detail.  Optional argument COLOR means highlight the
     prototype with font-lock colors.

 - Function: semantic-format-tag-summarize tag &optional parent color
     Summarize TAG in a reasonable way.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-prototype tag &optional parent color
     Return a prototype for TAG.  This function should be overloaded,
     though it need not be used.  This is because it can be used to
     create code by language independent tools.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-concise-prototype tag &optional parent
          color
     Return a concise prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-abbreviate tag &optional parent
          color
     Return a UML style abbreviation for TAG.  Optional argument PARENT
     is the parent type if TAG is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-prototype tag &optional parent
          color
     Return a UML style prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-concise-prototype tag &optional
          parent color
     Return a UML style concise prototype for TAG.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-prin1 tag &optional parent color
     Convert TAG to a string that is the print name for TAG.  PARENT
     and COLOR are ignored.

An additional utility will return a string for just the data type of a
tag.  This function is used in the above routines as well.

 - Function: semantic-format-tag-type tag color
     Convert the data type of TAG to a string usable in tag formatting.
     It is presumed that TYPE is a string or semantic tag.  This
     function can be overriden in semantic using the symbol
     `format-tag-type'.


File: semantic-appdev.info,  Node: Tag Members,  Next: Tag Details,  Prev: Format Tag,  Up: Override Methods

Tag Members
===========

Tags are often in a hierarchical form, meaning that a tag found in the
top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

 - Function: semantic-tag-components tag
     Return a list of components for TAG.  A Component is a part of TAG
     which itself may be a TAG.  Examples include the elements of a
     structure in a ``type' tag, or the list of arguments to a
     `'function' tag.

 - Function: semantic-tag-components-with-overlays tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.

     Default behavior is to get "semantic-tag-components" in addition
     to the components of an anonymous types (if applicable.)

     Note for language authors:   If a mode defines a language tag that
     has tags in it with overlays you should still return them with
     this function.  Ignoring this step will prevent several features
     from working correctly.

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.

 - Function: semantic-tag-external-member-p parent token
     Return non-`nil' if PARENT is the parent of TAG.  TAG is an
     external member of PARENT when it is somehow tagged as having
     PARENT as it's parent.  PARENT and TAG must both be semantic tags.

     The default behavior, if not overridden with
     `tag-external-member-p' is to match `'parent' extra specifier in
     the name of TAG.

     If this function is overridden, use
     `semantic-tag-external-member-children-p-default' to also include
     the default behavior, and merely extend your own.

 - Function: semantic-tag-external-member-children tag &optional usedb
     Return the list of children which are not *in* TAG.  If optional
     argument USEDB is non-`nil', then also search files in the
     Semantic Database.  If USEDB is a list of databases, search those
     databases.

     Children in this case are functions or types which are members of
     TAG, such as the parts of a type, but which are not defined inside
     the class.  C++ and CLOS both permit methods of a class to be
     defined outside the bounds of the class' definition.

     The default behavior, if not overridden with
     `tag-external-member-children' is to search using
     "semantic-tag-external-member-p" in all top level definitions with
     a parent of TAG.

     If this function is overridden, use
     "semantic-tag-external-member-children-default" to also include
     the default behavior, and merely extend your own.


File: semantic-appdev.info,  Node: Tag Details,  Next: Making New Methods,  Prev: Tag Members,  Up: Override Methods

Tag Details
===========

These functions help derive information about tags that may not be
obvious for non-traditional languages with their own token types.

 - Function: semantic-tag-protection tag &optional parent
     Return protection information about TAG with optional PARENT.
     This function returns on of the following symbols:    `nil'
     - No special protection.  Language dependent.     `'public'    -
     Anyone can access this TAG.     `'private'   - Only methods in the
     local scope can access TAG.     `'protected' - Like private for
     outside scopes, like public for child                 classes.
     Some languages may choose to provide additional return symbols
     specific to themselves.  Use of this function should allow for
     this.

     The default behavior (if not overridden with `tag-protection' is
     to return a symbol based on type modifiers.

     *Compatibility*: `semantic-tag-protection' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-protection' which is
     now obsolete.

 - Function: semantic-tag-protected-p tag protection &optional parent
     Non-`nil' if TAG is is protected.  PROTECTION is a symbol which
     can be returned by the method "semantic-tag-protection".  PARENT
     is the parent data type which contains TAG.

     For these PROTECTIONs, true is returned if TAG is:
    `nil'
          Always true

    private
          True if `nil'.

    protected
          True if private or `nil'.

    public
          True if private, protected, or `nil'.

 - Function: semantic-tag-abstract-p tag &optional parent
     Return non `nil' if TAG is abstract.  Optional PARENT is the
     parent tag of TAG.  In UML, abstract methods and classes have
     special meaning and behavior in how methods are overridden.  In
     UML, abstract methods are italicized.

     The default behavior (if not overridden with `tag-abstract' is to
     return true if `abstract' is in the type modifiers.

     *Compatibility*: `semantic-tag-abstract-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-abstract' which is now
     obsolete.

 - Function: semantic-tag-leaf-p tag &optional parent
     Return non `nil' if TAG is leaf.  Optional PARENT is the parent
     tag of TAG.  In UML, leaf methods and classes have special meaning
     and behavior.

     The default behavior (if not overridden with `tag-leaf' is to
     return true if `leaf' is in the type modifiers.

     *Compatibility*: `semantic-tag-leaf-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-leaf' which is now obsolete.

 - Function: semantic-tag-static-p tag &optional parent
     Return non `nil' if TAG is static.  Optional PARENT is the parent
     tag of TAG.  In UML, static methods and attributes mean that they
     are allocated in the parent class, and are not instance specific.
     UML notation specifies that STATIC entries are underlined.  This
     function can be overriden in semantic using the symbol
     `tag-static-p'.

     *Compatibility*: `semantic-tag-static-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-static' which is now obsolete.

 - Variable: semantic-dependency-include-path
     Defines the include path used when searching for files.  This
     should be a list of directories to search which is specific to the
     file being included.  If "semantic-find-dependency" is overridden
     for a given language, this path is most likely ignored.

     TODO: use ffap.el to locate such items.

 - Function: semantic-dependency-tag-file &optional tag
     Find the filename represented from TAG.  Depends on
     `semantic-dependency-include-path' for searching.  Always searches
     `.' first, then searches additional paths.

     *Compatibility*: `semantic-dependency-tag-file' introduced in
     semantic version 2.0 supercedes `semantic-find-dependency' which
     is now obsolete.

 - Function: semantic-prototype-file buffer
     Return a file in which prototypes belonging to BUFFER should be
     placed.  Default behavior (if not overridden) looks for a token
     specifying the prototype file, or the existence of an EDE variable
     indicating which file prototypes belong in.

 - Function: semantic-go-to-tag &optional tag parent
     Go to the location of TAG.  TAG may be a stripped element, in
     which case PARENT specifies a parent tag that has position
     information.  Different behaviors are provided depending on the
     type of tag.  For example, dependencies (includes) will seek out
     the file that is depended on (see "semantic-dependency-tag-file".

     *Compatibility*: `semantic-go-to-tag' introduced in semantic
     version 2.0 supercedes `semantic-find-nonterminal' which is now
     obsolete.

 - Function: semantic-texi-find-documentation name &optional type
     Find the function or variable NAME of TYPE in the texinfo source.
     NAME is a string representing some functional symbol.  TYPE is a
     string, such as "variable" or "Command" used to find the correct
     definition in case NAME qualifies as several things.  When this
     function exists, POINT is at the definition.  If the doc was not
     found, an error is thrown.  Note: TYPE not yet implemented.


File: semantic-appdev.info,  Node: Making New Methods,  Prev: Tag Details,  Up: Override Methods

Making New Methods
==================


File: semantic-appdev.info,  Node: Parser Features,  Next: Semantic Database,  Prev: Override Methods,  Up: Top

Parser Features
***************

If you write a program that uses a tag table in a persistent display or
database, it is necessary to know when tag tables change so that your
displays can be updated.  This is especially important as tags can be
replaced, changed, or deleted, and the associated overlays will then
throw errors when you try to use them.  Complete integration with tag
changes can be achieved via several hooks.

If you write an application that frequenly accesses the tags tables, it
is important to make sure those tags are up to date, and to make sure
you application does not adversely effect all the other minor modes
that may be running.

The semantic parser has many features and hooks that applications can
use to provide a good user experience.

* Menu:

* Editing Buffers::             Let the parser know you are changing a buffer.
* Parser State::                Knowing if the tag table is out of date
* Parser Hooks::                Knowing when tags change
* Lexical Safety::              Preventing lexical errors from making a mess


File: semantic-appdev.info,  Node: Editing Buffers,  Next: Parser State,  Up: Parser Features

Editing Buffers
===============

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

 - Variable: semantic-edits-are-safe
     When non-`nil', modifications do not require a reparse.  This
     prevents tokens from being marked dirty, and it prevents top level
     edits from causing a cache check.  Use this when writing programs
     that could cause a full reparse, but will not change the tag
     structure, such as adding or updating top-level comments.


File: semantic-appdev.info,  Node: Parser State,  Next: Parser Hooks,  Prev: Editing Buffers,  Up: Parser Features

Parser State
============

It is sometimes useful to know what the current parsing state is.
These function can let you know what level of re-parsing may be needed.
Careful choices on when to reparse can make your program much faster.

 - Function: semantic-parse-tree-needs-update-p
     Return non-`nil' if the current parse tree needs to be updated.

 - Function: semantic-parse-tree-needs-rebuild-p
     Return non-`nil' if the current parse tree needs to be rebuilt.

 - Function: semantic-parse-tree-unparseable-p
     Return non-`nil' if the current buffer has been marked unparseable.

 - Function: semantic-parse-tree-up-to-date-p
     Return non-`nil' if the current parse tree is up to date.


File: semantic-appdev.info,  Node: Parser Hooks,  Next: Lexical Safety,  Prev: Parser State,  Up: Parser Features

Parser Hooks
============

If you just want to know when a buffer changes, use this hook.

 - Variable: semantic-after-toplevel-cache-change-hook
     Hooks run after the buffer token list has changed.  This list will
     change when a buffer is reparsed, or when the token list in a
     buffer is cleared.  It is *NOT* called if the current token list
     partially reparsed.

     Hook functions must take one argument, which is the new list of
     tokens associated with this buffer.

     For language specific hooks, make sure you define this as a local
     hook.

If you want tighter interaction with how the user is editing different
tags, you can use this hook instead.

 - Variable: semantic-after-partial-cache-change-hook
     Hooks run after the buffer cache has been updated.

     This hook will run when the cache has been partially reparsed.
     Partial reparses are incurred when a user edits a buffer, and only
     the modified sections are rescanned.

     Hook functions must take one argument, which is the list of tokens
     updated in the current buffer.

     For language specific hooks, make sure you define this as a local
     hook.

It is also useful to clean up any data your application is using when
semantic flushes its tags table.

 - Variable: semantic-before-toplevel-cache-flush-hook
     Hooks run before the toplevel nonterminal cache is flushed.  For
     language specific hooks, make sure you define this as a local
     hook.  This hook is called before a corresponding
     `semantic-after-toplevel-cache-change-hook' which is also called
     during a flush when the cache is given a new value of nil.


File: semantic-appdev.info,  Node: Lexical Safety,  Prev: Parser Hooks,  Up: Parser Features

Lexical Safety
==============

If you application frequenly requests lists of tags upon user request,
it may be important to avoid lexical problems that frequenly occur when
the user has partially written an expression, such as starting a
string, or argument list.

You can protect your code from lexical problems with this macro:

 - Function: semantic-lex-catch-errors symbol &rest forms
     Using SYMBOL, execute FORMS catching lexical errors.  If FORMS
     results in a call to the parser that throws a lexical error, the
     error will be caught here without the buffer's cache being thrown
     out of date.  If there is an error, the syntax that failed is
     returned.  If there is no error, then the last value of FORMS is
     returned.

It is important to provide a good SYMBOL so that these macros can nest
correctly.

If you want your code to run anyway, even if there is a lexical error,
using this macro like this:

     (semantic-lex-catch-errors
        (semantic-fetch-tags))

will put the parser into the 'unparseable' state, and allow other
routines to request the tag table without incurring additional parser
attempts.


File: semantic-appdev.info,  Node: Semantic Database,  Next: Idle Scheduling,  Prev: Parser Features,  Up: Top

Semantic Database
*****************

Semanticdb is a database mechanism for storing tags parsed by semantic.
The database operates in the background, saving tags as they are
parsed between sessions.  When a file is read in, and there is a
previously created set of tags available for it, sematnicdb will save
time by not parsing the file, and using the cached copy.

In applications, semanticdb can provide access to the sum of all tags
in a project or in the basic system.  This database can they be
searched using a set of special routines.

* Menu:

* Semanticdb in Programs::      Basic usage.
* Semanticdb Tag Queries::      Searching for tokens in the databases.
* System Databases::            Special kinds of databases for system tags.


File: semantic-appdev.info,  Node: Semanticdb in Programs,  Next: Semanticdb Tag Queries,  Up: Semantic Database

Semanticdb in Programs::
========================

If you write a program using semanticdb, you will probably want to make
sure it is active in your program.

 - Function: semanticdb-minor-mode-p
     Return non-`nil' if `semanticdb-minor-mode' is active.

Since semanticdb is optional, it is best if a program can gracefully
degrade service when semanticdb is not available, or to throw an error
letting the user know it is required to be active.

At the simplest level, you can ask if a given file is in the database,
recieving a tag table.  Semanticdb will give you an accurate set of
tags just by asking.

 - Function: semanticdb-file-stream file
     Return a list of tags belonging to FILE.  If file has database
     tags available in the database, return them.  If file does not
     have tags available, then load the file, and create them.


File: semantic-appdev.info,  Node: Semanticdb Tag Queries,  Next: System Databases,  Prev: Semanticdb in Programs,  Up: Semantic Database

Semanticdb Tag Queries
======================

You can search for tags in the semantic database using the
semanticdb-find API.  It is important to note that database search
functions do not return a plain list of tags.  This is because some
tags may not be loaded in a buffer, which means that the found tag
would not have an overlay, and no way to determine where it came from.

As such, all search functions return a special Database Results list.

There are several types of searches, divided into groups by
implementation.  While it is possible to add new types of searches, or
write custom searches, the built in searches are usually the only ones
available in system backends *Note System Databases::.

When the term brute or brutish is used as a search criteria, that is
distinguishing between an include-path based search, and a search that
scans everything available in a project.

Non-brute force searches assume that all symbols available in a given
buffer are on the search path, or in some file that has been included,
imported, or otherwise indicated in the source file itself.  While not
always true for interpreted languages (such as Emacs Lisp), it is
common among declaritive languages.

Sometimes a brute force approach is needed, scanning every file
available to the database.  You may want to do this if your application
is collecting data unrelated to a file currently being worked on.

* Menu:

* DB Results::                  Accessing the results of a search.
* DB Search Paths::             The list of tables to search.
* DB Basic Name Search::        Searches based on name.
* DB Basic Brute Search::       Searches on common tag attributes.
* DB Advanced Search::          Complex searches on associations
* DB Generic Brute Search::     Do It Yourself search criteria


File: semantic-appdev.info,  Node: DB Results,  Next: DB Search Paths,  Up: Semanticdb Tag Queries

DB Results
----------

The successful results of a search returns a special list of the
following form:

        ( (DATABASE TAG1 TAG2 ...) (DATABASE2 TAG3 TAG4 ...) ...)

It should not be necessary to access the results in this way, however,
as there are several routines that can be used to access this list.

To turn a semanticdb search result into a simple tag table, use:

 - Function: semanticdb-strip-find-results results &optional
          find-file-match
     Strip a semanticdb search RESULTS to exclude objects.  This makes
     it appear more like the results of a `semantic-find-' call.
     Optional FIND-FILE-MATCH is not yet implemented.

To write a function that accepts a tag table, or a semanticdb search
result, use this to test if it is a semanticdb search result:

 - Function: semanticdb-find-results-p resultp
     Non-`nil' if RESULTP is in the form of a semanticdb search result.
     This query only really tests the first entry in the list that is
     RESULTP, but should be good enough for debugging assertions.

 - Function: semanticdb-find-result-with-nil-p resultp
     Non-`nil' of RESULTP is in the form of a semanticdb search result.
     `nil' is a valid value where a TABLE usually is, but only if the
     TAG results include overlays.  This query only really tests the
     first entry in the list that is RESULTP, but should be good enough
     for debugging assertions.

To operate on the search results as though it were a simple tags table,
or plain list, use these routines.

 - Function: semanticdb-find-result-length result
     Number of tags found in RESULT.

 - Function: semanticdb-find-result-nth result n
     In RESULT, return the Nth search result.  This is a 0 based search
     result, with the first match being element 0.

     The returned value is a cons cell: (TAG . TABLE) where TAG is the
     tag at the Nth position.  TABLE is the semanticdb table where the
     TAG was found.  Sometimes TABLE can be nil.

 - Function: semanticdb-find-result-nth-in-buffer result n
     In RESULT, return the Nth search result.  Like
     "semanticdb-find-result-nth", except that only the TAG is
     returned, and the buffer it is found it will be made current.  If
     the result tag has no position information, the originating buffer
     is still made current.


File: semantic-appdev.info,  Node: DB Search Paths,  Next: DB Basic Name Search,  Prev: DB Results,  Up: Semanticdb Tag Queries

DB Search Paths
---------------

For searches based on an include path (non-brutish) a path of tables
needs to be generated.  Searching a lot of tables is slow, which is why
a brutish search is not always recommended.  An include-based approach
can also generate a lot of tables, so you can control how detailed a
search is with a throttle variable.

Ideally, each language mode will have a mode-specific value for this
throttle value.  A user can also specify their own values if the
default is not good enough.

 - Variable: semanticdb-find-default-throttle
     The default throttle for `semanticdb-find' routines.  The throttle
     controls how detailed the list of database tables is for a symbol
     lookup.  The value is a list with the following keys:

    `file'
          The file the search is being performed from.  This option is
          here for completeness only, and is assumed to always be on.

    `local'
          Tables from the same local directory are included.  This
          includes files directly referenced by a file name which might
          be in a different directory.

    `project'
          Tables from the same local project are included If `project'
          is specified, then `local' is assumed.

    `unloaded'
          If a table is not in memory, load it.  If it is not cached on
          disk either, get the source, parse it, and create the table.

    `system'
          Tables from system databases.  These are specifically tables
          from system header files, or language equivalent.

    `recursive'
          For include based searches, includes tables referenced by
          included files.

    `omniscience'
          Included system databases which are omniscience, or somehow
          know everything.  Omniscience databases are found in
          `semanticdb-project-system-databases'.  The Emacs Lisp system
          DB is an omniscience database.


You can use the command `semanticdb-find-test-translate-path' to
interactively test out how the path translator is working.  The path
translation routines are:

 - Function: semanticdb-find-translate-path path brutish
     Translate PATH into a list of semantic tables.  Path translation
     involves identifying the PATH input argument in one of the
     following ways:   `nil' - Take the current buffer, and use it's
     include list   buffer - Use that buffer's include list.
     filename - Use that file's include list.  If the file is not
     in a buffer, see of there is a semanticdb table for it.  If
     not, read that file into a buffer.    tag - Get that tag's buffer
     of file file.  See above.    table - Search that table, and it's
     include list.    find result - Search the results of a previous
     find.

     In addition, once the base path is found, there is the possibility
     of each added table adding yet more tables to the path, so this
     routine can return a lengthy list.

     If argument BRUTISH is non-`nil', then instead of using the include
     list, use all tables found in the parent project of the table
     identified by translating PATH.  Such searches use brute force to
     scan every available table.

     The return value is a list of objects of type "semanticdb-table" or
     it's children.  In the case of passing in a find result, the result
     is returned unchanged.

     This routine uses "semanticdb-find-table-for-include" to translate
     specific include tags into a semanticdb table.  This function can
     be overloaded (see "define-mode-local-override" for details).

 - Function: semanticdb-find-table-for-include includetag &optional
          table
     For a single INCLUDETAG found in TABLE, find a "semanticdb-table"
     object INCLUDETAG is a semantic TAG of class `'include'.  TABLE as
     defined by "semantic-something-to-tag-table" to identify where the
     tag came from.  TABLE is optional if INCLUDETAG has an overlay of
     `:filename' attribute.  This function can be overloaded (see
     "define-mode-local-override" for details).


File: semantic-appdev.info,  Node: DB Basic Name Search,  Next: DB Basic Brute Search,  Prev: DB Search Paths,  Up: Semanticdb Tag Queries

DB Basic Name Search
--------------------

These searches scan a database table collection for tags based on name.
They are divided into normal and deep searches.  A deep search, as
with in buffer tag scanning, implies that all entries are scanned,
including those in type declarations.

Normal Searches:

 - Function: semanticdb-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-by-name-regexp regexp &optional path
          find-file-match
     Search for all tags matching REGEXP on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-for-completion prefix &optional path
          find-file-match
     Search for all tags matching PREFIX on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-by-class class &optional path
          find-file-match
     Search for all tags of CLASS on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

Deep Searches:

 - Function: semanticdb-deep-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-deep-find-tags-by-name-regexp regexp &optional
          path find-file-match
     Search for all tags matching REGEXP on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-deep-find-tags-for-completion prefix &optional
          path find-file-match
     Search for all tags matching PREFIX on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.


File: semantic-appdev.info,  Node: DB Basic Brute Search,  Next: DB Advanced Search,  Prev: DB Basic Name Search,  Up: Semanticdb Tag Queries

DB Basic Brute Search
---------------------

These searches allow searching on specific attributes of tags,  such as
name, type, or other attribute.

 - Function: semanticdb-brute-deep-find-tags-by-name name &optional
          path find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.  The
     argument BRUTISH will be set so that searching includes all tables
     in the current project.  FIND-FILE-MATCH indicates that any time a
     matchi is found, the file associated wit that tag should be loaded
     into a buffer.


File: semantic-appdev.info,  Node: DB Advanced Search,  Next: DB Generic Brute Search,  Prev: DB Basic Brute Search,  Up: Semanticdb Tag Queries

DB Advanced Search
------------------

These are searches that were needed to accomplish some  specialized
tasks as discovered in utilities.  Advanced searches  include matching
methods defined outside some parent class.

The reason for advanced searches are so that external  repositories
such as the Emacs obarray, or java `.class' files can  quickly answer
these needed questions without dumping the entire  symbol list into
Emacs for a regular semanticdb search.

 - Function: semanticdb-find-tags-external-children-of-type type
          &optional path find-file-match
     Search for all tags defined outside of TYPE w/ TYPE as a parent.
     See "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

